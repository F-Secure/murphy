'''Copyright (c) 2011-2013 F-SecureSee LICENSE for detailsBase helper class for application crawling, see basic example at extract_7zip'''import os, sysimport unicodedatafrom model_extraction.vm_world import VmWorldfrom model_extraction.crawler import Crawlerfrom model_extraction.ui_graph import UIGraphfrom model_extraction.murphy_project import Projectfrom model_extraction.image2 import Image2from model_extraction.ui.ui_element import UIElementfrom model_extraction.ui.utils import TASKBAR_HEIGHTfrom model_extraction.automation_helpers import solve_active_window_rectfrom model_extraction.ui.window_scrap import suggest_node_name,\    suggest_node_file_namefrom model_extraction import configurationimport loggingLOGGER = logging.getLogger('root.' + __name__)LAUNCH_APP_TEMPLATE = \    '''def launch_application():    \'\'\'    Launches the desired application    \'\'\'    import time        use_command = WORKER.properties.get('command to launch', '')    if use_command == '':        use_command = r'%s'        WORKER.Wait(HERE['desc'])    #We need a bit more time to finish booting...    time.sleep(3)        WORKER.input.keyboard.enters('{+ctrl}{esc}{-ctrl}')    WORKER.input.keyboard.enters(use_command)    WORKER.input.keyboard.enters('{enter}')'''#FIXME: move to generic utilsdef import_by_filename(fullpath):    '''    Imports a module given a full path, bit hackish...    '''    new_dir = os.path.abspath(os.path.dirname(fullpath))    added_to_path = False    if not new_dir in sys.path:         sys.path.append(new_dir)        added_to_path = True        try:        module_file = os.path.basename(fullpath)        LOGGER.debug("Importing module %s from %s" % (module_file, new_dir))        return __import__(module_file)    finally:        if added_to_path:            del sys.path[-1]      class BaseExtractor(object):    '''    Base utility helper for extracting an application model, for a basic    sample see extract_7zip    '''    def __init__(self, model_name, command, images_dir='img', override=True,        rules_template=None, vm_class=None):        self._model_name = os.path.basename(model_name)        self._images_dir = images_dir        self._command = command        self._boundary_nodes = {}        if vm_class is None:            if rules_template is None:                rules_template = configuration.get_default_config()["module"]                if os.path.isabs(rules_template) == False:                    rules_template = os.path.dirname(os.path.abspath(__file__)) + "/" + rules_template            module = import_by_filename(rules_template.replace('.py', ''))            vm_class = module.get_remoting_vnc_object        this_dir = os.path.dirname(os.path.abspath(__file__))        close_images = [Image2(file_name=this_dir                        + '/templates/img/close 1.bmp'),                        Image2(file_name=this_dir                        + '/templates/img/close 2.bmp')]        self.close_button = UIElement(close_images)        self.world = VmWorld(vm_class)        base_dir = os.path.dirname(model_name)        if base_dir == '':            base_dir = '.'                            self.graph = UIGraph(base_dir, self._model_name, self._images_dir)        self.graph.scrap_method = self.scrap_state        self.project = Project(self.graph, rules_template=rules_template)        self.project.create(override_if_exists=override)        self.crawler = Crawler(self.world, self.graph)        self.world.instrumentation_log_dest_path = self.project.path        self.graph.on_update = self.update_project        self.graph.classify_node = self.node_classification        # Either pre or post creation hook for classifier        self.node_classification_uses_post_hook = True        self.scrap_method = None        self.use_fast_run_command = True    def scrap_state(self, node, world, scraper_hints, node_hints):        '''        Scrap current state, either with the default scraper or the provided        one        '''        if self.scrap_method:            self.scrap_method(node, world, scraper_hints, node_hints) #pylint: disable=E1102, C0301        else:            from model_extraction.ui import scraper            scraper.scrap_state(node, world, scraper_hints, node_hints)              def customize_crawl(self):        '''        Override in derived class, add here ignorable edges, crawler hints and        any other customizations of the crawling behavior        '''        self.graph.add_create_node_hook(0, self.initial_node)    def crawl_application(self):        '''        Applies any customization to the crawler (by calling the customize        crawl method) and crawls it.        '''        self.customize_crawl()        try:            LOGGER.debug("Starting crawl")            self.world.reset()            LOGGER.debug("Crawl started")            self.crawler.explore()        except Exception, ex:            if self.world and self.world.machine and self.world.machine.automation:                screen = self.world.machine.automation.grab_screen()                screen.save('Screen when failed.bmp')            raise        finally:            self.world.dispose()    def continue_crawl(self):        try:            self.crawler.explore()        except Exception:            if self.world and self.world.machine and self.world.machine.automation:                screen = self.world.machine.automation.grab_screen()                screen.save('Screen when failed.bmp')            raise        finally:            self.world.dispose()        def initial_node(self, node, world):        '''        The initial node is simply composed by the booted machine + the launch         application edge        '''        node.name = 'Node 0'        node.file_name = 'node_00'        screen = world.machine.automation.grab_screen()        screen = screen.crop((0, 0, screen.size[0], screen.size[1]                             - TASKBAR_HEIGHT))        screen = Image2(image=screen)        node.screenshots.append(screen)        node.reference_images.append(screen)        edge = node.create_edge('Launch application')        edge.method = self.launch_application        edge.method_source_code = ('launch_application',                                   LAUNCH_APP_TEMPLATE % self._command)    def update_project(self, node):        '''        Saves the project, nodes and edges        '''        self.project.save()        if node:            node.save()            node.save_as_python()        else:            self.project.graph.save_nodes()    def launch_application(self, world):        '''        Method for launching the application to be modelled from within the        model extraction tool        '''        if self.use_fast_run_command == True and world.machine.helper:            world.machine.helper.execute("start " + self._command)        else:            world.machine.automation.run_command(self._command)    def add_boundary_node(self, title_or_index):        '''        Considers the given node as a boundary, all the edges on it will not be        crawled        '''        self._boundary_nodes[title_or_index] = True    def boundary_node(self, node, world):        '''        Marks all the edges of this node as ignorables so they are not crawled,        override this implementation if something else is desired, like for        example searching for the close button at the top right, removing all        the edges of this node, etc.        '''        node_index = self.graph.nodes.index(node)        for edge_index in range(len(node.edges)):            self.crawler.ignorable_edges.append((node_index, edge_index))    def boundary_node_returnable(self, node, world):        '''        Creates a boundary node out of this node.        A boundary node is a node we're not interested to scrap, but if possible        we want to find a close button to go back to previous node.        close_button must be a UIElement that can be recognize (usually the        button at the top-right of a window)        '''        window_title = world.machine.helper.get_current_window_title()        node.title = window_title        # scrap        node_index = self.graph.nodes.index(node)        node.name = suggest_node_name(window_title, node)        node.file_name = suggest_node_file_name(node)        screen = world.machine.automation.grab_screen()        (_, rect) = solve_active_window_rect(world, screen)        # FIXME: needs better parametrization        color = (237, 28, 36, 0)        color_mask = 0xed1c2400        dialog = screen.crop(rect)        reference = Image2(image=dialog)        node.reference_images.append(reference)        found = self.close_button.find_in(reference)        if found:            print 'Close button found as %s' % str(found)            edge = node.create_edge('Close')            for img in self.close_button.images:                edge.screenshots.append(Image2(image=img.image))            edge.location = found            dialog.paste(color, found)        ignorable_areas = self.graph.node_hints.get(node_index, {})        ignorable_areas = ignorable_areas.get('ignorable', [])        for area in ignorable_areas:            dialog.paste(color, area)        dialog = Image2(image=dialog, color_mask=color_mask)        node.screenshots.append(dialog)        return False    def node_classification(        self,        graph,        node,        world,        ):        '''        Classifies the given node if it is a boundary or not, also attaches         post_create_node_hook dynamically based on window title        '''        window_title = world.machine.helper.get_current_window_title()        if isinstance(window_title, unicode):            LOGGER.info('Window title found is %s' \                        % unicodedata.normalize('NFKD',                                        window_title).encode('ascii', 'ignore'))        else:            LOGGER.info('Window title found is %s' % window_title)        node.title = window_title        node_index = graph.nodes.index(node)        uses_hook = False        for key in self._boundary_nodes.keys():            if not type(key) is int:                if window_title.find(key) != -1:                    uses_hook = True                    break        if node_index in self._boundary_nodes or uses_hook:            if self.node_classification_uses_post_hook == True:                graph.add_post_create_node_hook(node_index,                        self.boundary_node)            else:                graph.add_pre_create_node_hook(node_index,                        self.boundary_node)        return True    def inject_edge(        self,        node,        location,        name=None,        ui_type=None        ):        '''        Adds an edge to the given node for the given coordinates, the        coordinates should be relative to the node, not the whole screen.        Use this to inject ui elements that are not automatically or properly        scrapped.        '''        if name is None:            name = 'Element %s' % len(node.edges)        edge = node.create_edge(name)        image = node.reference_images[0].image.crop(location)        edge.screenshots.append(Image2(image=image))        edge.location = location        edge.ui_type = ui_type        return edge    def node_from_desktop(self, node, world):        '''        Creates this node taking the whole desktop        '''        node.name = suggest_node_name('Desktop', node)        node.file_name = suggest_node_file_name(node)        screen = world.machine.automation.grab_screen()        screen = screen.crop((0, 0, screen.size[0], screen.size[1]                             - TASKBAR_HEIGHT))        screen = Image2(image=screen)        node.screenshots.append(screen)        node.reference_images.append(screen)                    def node_from_screen_rect(self, node, world, rect):        '''        Creates this node taking the given screen rect        '''        node.last_location = rect        screen = world.machine.automation.grab_screen()                node.screenshots = []        reference = Image2(image=screen.crop(rect))        node.reference_images = [reference]                