'''Copyright (c) 2011-2014 F-SecureSee LICENSE for detailsExperimental implementation of a window scraper'''import time, loggingfrom model_extraction.image2 import Image2from model_extraction import automation_helpersfrom murphy.utils import is_valid_verb_name, is_valid_view_namefrom model_extraction.code_generation import letterize, fix_repetitionLOGGER = logging.getLogger('root.' + __name__)NEXT_TAB_TEMPLATE = \    '''def next_tab():    WORKER.input.keyboard.enters('{+ctrl}{tab}{-ctrl}')'''NEXT_TAB_CONTROL = '{+ctrl}{tab}{-ctrl}'PREV_TAB_CONTROL = '{+ctrl}{+shift}{tab}{-shift}{-ctrl}'def is_inside(rect, rect2):    '''    Returns True if rect is inside rect2    '''    if rect['left'] >= rect2['left'] and rect['right'] <= rect2['right'            ] and rect['top'] >= rect2['top'] and rect['bottom'] \        <= rect2['bottom']:        return True    else:        return Falsedef is_framing(window, all_windows):    '''    If there are other valid controls (SysLink, button, combobox) inside then    this one is most likely framing    '''    for win in all_windows:        if win['hwnd'] != window['hwnd']:            if win['class'] in ['ComboBox', 'Button', 'SysLink', 'Static']:                if is_inside(win['rect'], window['rect']):                    return True    return Falsedef suggest_node_name(text, node):    '''    Try best guess for naming a node given the window title    '''    # FIXME: & followed by a letter should be eliminated but when is between    # spaves it should be letterized    suggested = text.replace('...', '').replace('&', '').strip()    suggested = letterize(suggested)    suggested = suggested.title()    node_names = [a_node.name for a_node in node.graph.nodes]    suggested = fix_repetition(suggested, node_names)    if is_valid_view_name(suggested):        return suggested    else:        # Node is created already... so len - 1 for typical 0 based        return 'Node %s' % (len(node.graph.nodes) - 1)def suggest_node_file_name(node):    '''    Returns a node file name based on the node name    '''    return node.name.replace(' ', '_').lower()                        def suggest_edge_name(text, alternate, node):    '''    Try best gess for a generic edge name    '''    # FIXME: & followed by a letter should be eliminated but when is between    # spaves it should be letterized        suggested = text.replace('...', '').replace('&', '').strip()    suggested = letterize(suggested)    suggested = suggested.capitalize()    edge_names = [an_edge.name for an_edge in node.edges]    suggested = fix_repetition(suggested, edge_names)    if is_valid_verb_name(suggested):        LOGGER.info('Edge with text %s name will be %s' % (suggested,                                                           suggested))        return suggested    else:        LOGGER.info('Edge with text %s name will be %s' % (suggested,                                                           alternate))        return alternatedef suggest_combo_name(combo, controls, screen_size, alternate, node):    '''    A name for a combo is usually guessed as the closest label right above    or left from the control    We compute the closest distance from bottom left corner of labels    and top right corner against top left corner of the combobox    '''        #name = suggest_edge_name(control['wm text'], name, node)    candidate = None    top_left = (combo['rect']['top'] * screen_size[0]) + combo['rect']['left']    closest = 1000000    for control in controls:        if control['class'] == 'Static' and len(control['text']) > 2:            bottom_left = ((control['rect']['bottom'] * screen_size[0]) +                            control['rect']['left'])            distance = abs(bottom_left - top_left)            if distance < closest:                candidate, closest = control, distance                            top_right = ((control['rect']['top'] * screen_size[0]) +                          control['rect']['right'])            distance = abs(top_right - top_left)            if distance < closest:                candidate, closest = control, distance    return suggest_edge_name(candidate['text'], alternate, node)                                def scrap_tab_control(node, world):    '''    Try ctrl tab to see if there's some tabbed control in it    '''    world.machine.automation.keyboard.enters('{+ctrl}{tab}{-ctrl}')    time.sleep(1)    screen = Image2(world.machine.automation.grab_screen())    if screen.find(node.screenshots[0])[0] == False:        suggested = 'Next tab'        edge_names = [an_edge.name for an_edge in node.edges]        suggested = fix_repetition(suggested, edge_names)        edge = node.create_edge(suggested)        edge.method = lambda world: \            world.machine.automation.keyboard.enters(NEXT_TAB_CONTROL)        edge.method_source_code = ('next_tab', NEXT_TAB_TEMPLATE)        world.machine.automation.keyboard.enters(PREV_TAB_CONTROL)def scrap_desktop(node, world, screen):    '''    We compare current screen against first desktop node in list, deduce if    there's one new icon, if so we can take that instead of the whole screen    '''    prev_desktop = None    LOGGER.info("Scraping a desktop")    for a_node in node.graph.nodes:        if ('scrap' in a_node.custom and           a_node.custom['scrap'].get('desktop', 'no') == 'yes'):            prev_desktop = a_node            break            if prev_desktop:        LOGGER.info("Have a previous desktop, looking for new icons...")        desk_before = prev_desktop.reference_images[0]        desk_now = Image2(image=screen)        icon_coords = desk_now.difference(desk_before)        if icon_coords:            world.machine.automation.mouse.click(icon_coords[0] + 5,                                                 icon_coords[1] + 5)            world.machine.automation.mouse.move(1, 1)            icon_selected_screen = world.machine.automation.grab_screen()            world.machine.automation.mouse.click()            icon_framed_screen = world.machine.automation.grab_screen()            desk_now = Image2(image=icon_selected_screen)            icon_coords = desk_now.difference(desk_before)                        icon_unselected = screen.crop((icon_coords[0],                                           icon_coords[1],                                           icon_coords[2] + 1,                                           icon_coords[3] + 1))            icon_selected = icon_selected_screen.crop((icon_coords[0],                                                       icon_coords[1],                                                       icon_coords[2] + 1,                                                       icon_coords[3] + 1))            icon_framed = icon_framed_screen.crop((icon_coords[0],                                                   icon_coords[1],                                                   icon_coords[2] + 1,                                                   icon_coords[3] + 1))            node.custom['scrap'] = {'desktop': 'yes'}            node.last_location = icon_coords            node.desktop_icon = True            node.reference_images.append(Image2(icon_unselected))                        node.screenshots.append(Image2(image=icon_unselected,                                           color_mask=0xed1c2400,                                           tolerance=0.99))            node.screenshots.append(Image2(image=icon_selected,                                           color_mask=0xed1c2400,                                           tolerance=0.99))            node.screenshots.append(Image2(image=icon_framed,                                           color_mask=0xed1c2400,                                           tolerance=0.99))            edge = node.create_edge('Launch')            edge.ui_type = 'desktop icon'            edge.location = [10, 10, 12, 12]            return True            return Falsedef remove_controls_on_top(node):    '''    Removes edges that are too close to the title bar like custom close buttons    '''    for i in range(len(node.edges) - 1, -1, -1):        if node.edges[i].location[1] < 10:            node.edges.pop(i)def add_ignorable_rect(node, rect):    '''    Ignores the given rect in the node as an ignorable area, this is meant to    be used after overall parametrization has been done     '''    LOGGER.info('Adding ignorable rect %s to node %s' % (str(rect), node.name))    node_image = node.screenshots[0].image    color = (237, 28, 36, 0)    node_image.paste(color, rect)    node_image = Image2(image=node_image, color_mask=0xed1c2400, tolerance=0.99)        node.screenshots = [node_image]        def custom_scraper(node, world):    '''    Do scrap using the window scraper    '''    scrap = world.machine.helper.scrap_active_window()    node.custom['scrap'] = scrap    screen = world.machine.automation.grab_screen()    (is_desktop, window_rect) = \                      automation_helpers.solve_active_window_rect(world, screen)        node.name = None    if is_desktop:        node.name = suggest_node_name('Desktop', node)        node.file_name = suggest_node_file_name(node)        if scrap_desktop(node, world, screen):            return False            if node.name is None: # name from topmost static instead of window title        first_static = None        first_static_pos = 0        for control in scrap['childs']:            if control['class'] == 'Static' and len(control['text']) > 2:                pos = control['rect']['top'] * screen.size[0]                 pos += control['rect']['left']                if pos < first_static_pos or first_static is None:                    first_static = control                    first_static_pos = pos                if first_static:            node.name = suggest_node_name(first_static['text'], node)            node.file_name = suggest_node_file_name(node)    if node.name is None:        node.name = suggest_node_name(scrap['text'], node)        node.file_name = suggest_node_file_name(node)    node.last_location = window_rect    node.fixed_position = False    dialog = screen.crop(window_rect)    node.reference_images.append(Image2(dialog))    for control in scrap['childs']:        name = 'Element %s' % len(node.edges)        location = (control['rect']['left'] - window_rect[0],                    control['rect']['top'] - window_rect[1],                    control['rect']['right'] - window_rect[0],                    control['rect']['bottom'] - window_rect[1])        valid = False        if control['enabled']:            if control['class'] in ['ComboBox']:                name = suggest_combo_name(control,                                          scrap['childs'],                                          screen.size,                                          name,                                          node)                #name = suggest_edge_name(control['wm text'], name, node)                control_type = 'normal'                valid = True            elif control['class'] == 'Button' and is_framing(control,                    scrap['childs']) == False:                name = suggest_edge_name(control['text'], name, node)                control_type = 'normal'                valid = True            elif control['class'] == 'SysLink':                link_text = control['text']                #FIXME: real parser needed, this is hackish...                link_text = link_text[link_text.find(">") + 1:link_text.rfind("<")]                name = suggest_edge_name(link_text, name, node)                control_type = 'link'                valid = True            elif control['class'] == 'Edit':                #FIXME: recommend static at left or top as it is usually the label of it                name = suggest_edge_name("Text input", name, node)                control_type = 'text'                valid = True            if valid:                edge = node.create_edge(name)                edge.custom['window'] = control                edge.location = location                edge.ui_type = control_type                edge.screenshots.append(Image2(dialog.crop(location)))    node.custom['scraper'] = 'windows api'                return False